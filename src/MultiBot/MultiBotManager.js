import ColorLogger from '../Utils/ColorLogger.js';
import AccountConfig from '../Config/AccountConfig.js';
import BotInstance from './BotInstance.js';

/**
 * Gerenciador principal para m√∫ltiplas inst√¢ncias do bot
 * Controla a execu√ß√£o paralela de diferentes contas/estrat√©gias
 */
class MultiBotManager {
  constructor() {
    this.bots = new Map(); // Map<botName, BotInstance>
    this.logger = new ColorLogger('MANAGER', 'MULTI');
    this.isRunning = false;
    this.selectedBots = [];
  }

  /**
   * Inicializa o gerenciador
   */
  async initialize() {
    this.logger.info('Inicializando MultiBot Manager...');
    
    // Carrega e valida configura√ß√µes
    this.accountConfig = new AccountConfig();
    await this.accountConfig.initialize();
    
    // Valida configura√ß√µes
    const validation = this.accountConfig.validateConfigurations();
    if (!validation.isValid) {
      this.logger.error('Configura√ß√µes inv√°lidas:');
      validation.errors.forEach(error => this.logger.error(`  ‚Ä¢ ${error}`));
      return false;
    }
    
    // Verifica se h√° contas configuradas
    if (!this.accountConfig.hasAnyAccount()) {
      this.logger.error('Nenhuma conta com credenciais v√°lidas encontrada');
      return false;
    }
    
    this.logger.success('MultiBot Manager inicializado com sucesso');
    return true;
  }

  /**
   * Mostra menu de sele√ß√£o de modo
   */
  async showModeSelection() {
    console.log('\nü§ñ BACKBOT - Sele√ß√£o de Modo');
    console.log('=====================================');
    console.log('\nüìã Modos Dispon√≠veis:\n');
    
    console.log('1Ô∏è‚É£  CONTA √öNICA');
    console.log('   ‚Ä¢ Uma conta, uma estrat√©gia');
    console.log('   ‚Ä¢ Modo atual do bot\n');
    
    console.log('2Ô∏è‚É£  M√öLTIPLAS CONTAS');
    console.log('   ‚Ä¢ Duas contas, estrat√©gias diferentes');
    console.log('   ‚Ä¢ Logs separados por conta');
    console.log('   ‚Ä¢ Execu√ß√£o em paralelo\n');
    
    console.log('3Ô∏è‚É£  Sair\n');
    
    // Verifica se h√° contas configuradas
    const enabledAccounts = AccountConfig.getEnabledAccounts();
    if (enabledAccounts.length === 0) {
      console.log('‚ö†Ô∏è  Nenhuma conta habilitada encontrada');
      console.log('   Configure as contas no arquivo .env\n');
      return 'SINGLE';
    }
    
    console.log('üìä Contas Configuradas:');
    enabledAccounts.forEach(account => {
      console.log(`   ‚Ä¢ ${account.id}: ${account.name} (${account.strategy})`);
    });
    console.log('');
    
    return 'MULTI';
  }

  /**
   * Mostra menu de sele√ß√£o de contas
   */
  async showAccountSelection() {
    const enabledAccounts = this.accountConfig.getEnabledAccounts();
    
    console.log('\nü§ñ Sele√ß√£o de Contas');
    console.log('=====================================\n');
    
    console.log('üìã Contas Dispon√≠veis:\n');
    
    enabledAccounts.forEach((account, index) => {
      const status = account.enabled ? '‚úÖ Ativo' : '‚ùå Inativo';
      console.log(`${index + 1}Ô∏è‚É£  ${account.id}: ${account.name}`);
      console.log(`   ‚Ä¢ Estrat√©gia: ${account.strategy}`);
      console.log(`   ‚Ä¢ Status: ${status}`);

      console.log(`   ‚Ä¢ Capital: ${account.capitalPercentage}%`);
      console.log(`   ‚Ä¢ Timeframe: ${account.time}\n`);
    });
    
    console.log(`${enabledAccounts.length + 1}Ô∏è‚É£  TODAS AS CONTAS`);
    console.log('   ‚Ä¢ Executa todas as contas habilitadas\n');
    
    console.log(`${enabledAccounts.length + 2}Ô∏è‚É£  Voltar\n`);
    
    // Simula sele√ß√£o (em implementa√ß√£o real, seria input do usu√°rio)
    return enabledAccounts.map(account => account.id);
  }

  /**
   * Inicia os bots selecionados
   */
  async startBots(botNames) {
    try {
      this.logger.info(`Iniciando ${botNames.length} bot(s)...`);
      
      for (const botName of botNames) {
        const account = this.accountConfig.getAccount(botName);
        if (!account) {
          this.logger.error(`Bot ${botName} n√£o encontrado`);
          continue;
        }
        
        if (!account.enabled) {
          this.logger.warn(`Bot ${botName} est√° desabilitado`);
          continue;
        }
        
        const botInstance = new BotInstance(botName, account);
        this.bots.set(botName, botInstance);
      }
      
      // Inicia todos os bots em paralelo
      const startPromises = Array.from(this.bots.values()).map(bot => bot.start());
      const results = await Promise.all(startPromises);
      
      // Verifica resultados
      const successful = results.filter(result => result === true).length;
      const failed = results.filter(result => result === false).length;
      
      this.logger.success(`${successful} bot(s) iniciado(s) com sucesso`);
      if (failed > 0) {
        this.logger.error(`${failed} bot(s) falharam ao iniciar`);
      }
      
      this.isRunning = successful > 0;
      this.selectedBots = botNames;
      
      if (this.isRunning) {
        this.logger.success('MultiBot iniciado com sucesso!');
        this.showStatus();
      }
      
      return this.isRunning;
      
    } catch (error) {
      this.logger.error(`Erro ao iniciar bots: ${error.message}`);
      return false;
    }
  }

  /**
   * Para todos os bots
   */
  stopBots() {
    try {
      this.logger.info('Parando todos os bots...');
      
      for (const [botName, bot] of this.bots) {
        bot.stop();
      }
      
      this.bots.clear();
      this.isRunning = false;
      this.selectedBots = [];
      
      this.logger.success('Todos os bots parados com sucesso');
      
    } catch (error) {
      this.logger.error(`Erro ao parar bots: ${error.message}`);
    }
  }

  /**
   * Mostra status dos bots
   */
  showStatus() {
    console.log('\nüìä Status dos Bots');
    console.log('=====================================');
    
    if (this.bots.size === 0) {
      console.log('‚ùå Nenhum bot em execu√ß√£o');
      return;
    }
    
    for (const [botName, bot] of this.bots) {
      const status = bot.getStatus();
      const runningStatus = status.isRunning ? 'üü¢ Executando' : 'üî¥ Parado';
      
      console.log(`\n${botName}: ${status.name}`);
      console.log(`   ‚Ä¢ Estrat√©gia: ${status.strategy}`);
      console.log(`   ‚Ä¢ Status: ${runningStatus}`);

      console.log(`   ‚Ä¢ Capital: ${status.capitalPercentage}%`);
      console.log(`   ‚Ä¢ Timeframe: ${status.time}`);
    }
    
    console.log('\nüí° Use Ctrl+C para parar todos os bots');
  }

  /**
   * Obt√©m status de todos os bots
   */
  getAllStatus() {
    const status = [];
    
    for (const [botName, bot] of this.bots) {
      status.push(bot.getStatus());
    }
    
    return status;
  }

  /**
   * Verifica se h√° bots em execu√ß√£o
   */
  hasRunningBots() {
    return this.isRunning && this.bots.size > 0;
  }

  /**
   * Obt√©m n√∫mero de bots em execu√ß√£o
   */
  getRunningBotsCount() {
    return Array.from(this.bots.values()).filter(bot => bot.isRunning).length;
  }

  /**
   * Executa em modo conta √∫nica (compatibilidade)
   */
  async runSingleMode() {
    this.logger.info('Executando em modo conta √∫nica...');
    
    // Usa configura√ß√µes padr√£o
    const accountConfig = new AccountConfig();
    const defaultAccount = accountConfig.getEnabledAccounts()[0];
    if (!defaultAccount) {
      this.logger.error('Nenhuma conta configurada para modo √∫nico');
      return false;
    }
    
    return await this.startBots([defaultAccount.id]);
  }

  /**
   * Executa em modo m√∫ltiplas contas
   */
  async runMultiMode() {
    this.logger.info('Executando em modo PRO MAX...');
    
    // Garante que o AccountConfig foi inicializado
    if (!this.accountConfig) {
      await this.initialize();
    }
    
    // Filtra apenas contas com estrat√©gia PRO_MAX
    const allAccounts = this.accountConfig.getAllAccounts();
    const proMaxAccounts = allAccounts.filter(account => account.strategy === 'PRO_MAX' && account.enabled);
    
    if (proMaxAccounts.length === 0) {
      this.logger.error('Nenhuma conta PRO_MAX habilitada encontrada');
      this.logger.info('Configure uma conta com ACCOUNT2_STRATEGY=PRO_MAX no .env');
      return false;
    }
    
    const botNames = proMaxAccounts.map(account => account.botName);
    this.logger.info(`Iniciando ${botNames.length} bot(s) PRO_MAX: ${botNames.join(', ')}`);
    
    const success = await this.startBots(botNames);
    
    if (success) {
      // Inicia o timer geral para modo multi-bot
      this.startGlobalTimer();
      
      // Configura o timer para se repetir a cada 60 segundos
      setInterval(() => {
        this.startGlobalTimer();
      }, 60000);
    }
    
    return success;
  }

  /**
   * Inicia o timer geral para modo multi-bot
   */
  startGlobalTimer() {
    const durationMs = 60000; // 60 segundos
    const startTime = Date.now();
    const nextAnalysis = new Date(startTime + durationMs);
    const timeString = nextAnalysis.toLocaleTimeString('pt-BR', { 
      hour: '2-digit', 
      minute: '2-digit', 
      second: '2-digit',
      hour12: false 
    });

    // Intercepta console.log para manter o progresso no rodap√©
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;
    
    // Fun√ß√£o para limpar a linha do progresso
    const clearProgressLine = () => {
      process.stdout.write('\r' + ' '.repeat(process.stdout.columns || 80) + '\r');
    };
    
    // Fun√ß√£o para mostrar o progresso no rodap√©
    const showProgress = (progress, progressBar, percentage) => {
      // Move o cursor para o final da tela
      process.stdout.write('\x1b[9999;0H');
      // Limpa a linha atual
      clearProgressLine();
      // Mostra o progresso
      process.stdout.write('‚è≥ Aguardando pr√≥xima an√°lise... ');
      process.stdout.write(`[${progressBar}] ${percentage}% | Pr√≥xima: ${timeString}`);
    };

      // Intercepta console.log para manter o progresso no rodap√©
  console.log = (...args) => {
    // Filtra logs que podem quebrar a barra de progresso
    const message = args.join(' ');
    const isSpamLog = message.includes('Stop loss j√° existe') || 
                     message.includes('‚ÑπÔ∏è [CONTA') ||
                     message.includes('‚ö†Ô∏è [CONTA');
    
    // Se for log de spam, n√£o mostra para n√£o quebrar a barra
    if (isSpamLog) {
      return;
    }
    
    // Limpa a linha do progresso antes de mostrar o log
    clearProgressLine();
    // Mostra o log
    originalLog.apply(console, args);
    // Restaura o progresso no rodap√©
    const elapsed = Date.now() - startTime;
    const progress = Math.min((elapsed / durationMs) * 100, 100);
    const bars = Math.floor(progress / 5);
    const emptyBars = 20 - bars;
    const progressBar = '‚ñà'.repeat(bars) + '‚ñë'.repeat(emptyBars);
    const percentage = Math.floor(progress);
    showProgress(progress, progressBar, percentage);
  };

    // Intercepta console.error
    console.error = (...args) => {
      clearProgressLine();
      originalError.apply(console, args);
      const elapsed = Date.now() - startTime;
      const progress = Math.min((elapsed / durationMs) * 100, 100);
      const bars = Math.floor(progress / 5);
      const emptyBars = 20 - bars;
      const progressBar = '‚ñà'.repeat(bars) + '‚ñë'.repeat(emptyBars);
      const percentage = Math.floor(progress);
      showProgress(progress, progressBar, percentage);
    };

    // Intercepta console.warn
    console.warn = (...args) => {
      clearProgressLine();
      originalWarn.apply(console, args);
      const elapsed = Date.now() - startTime;
      const progress = Math.min((elapsed / durationMs) * 100, 100);
      const bars = Math.floor(progress / 5);
      const emptyBars = 20 - bars;
      const progressBar = '‚ñà'.repeat(bars) + '‚ñë'.repeat(emptyBars);
      const percentage = Math.floor(progress);
      showProgress(progress, progressBar, percentage);
    };

    const timerInterval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min((elapsed / durationMs) * 100, 100);
      const bars = Math.floor(progress / 5);
      const emptyBars = 20 - bars;
      
      const progressBar = '‚ñà'.repeat(bars) + '‚ñë'.repeat(emptyBars);
      const percentage = Math.floor(progress);
      
      // Mostra o progresso no rodap√©
      showProgress(progress, progressBar, percentage);
      
      if (progress >= 100) {
        clearInterval(timerInterval);
        // Restaura console.log original
        console.log = originalLog;
        console.error = originalError;
        console.warn = originalWarn;
        // Limpa a linha do progresso
        clearProgressLine();
        console.log('üîÑ Iniciando nova an√°lise...\n');
      }
    }, 1000);

    // Retorna o intervalo para poder parar se necess√°rio
    return timerInterval;
  }

  /**
   * Coordena os logs dos bots para evitar conflitos
   */
  coordinateLogs() {
    // Pausa temporariamente os logs dos bots durante o timer
    for (const [botName, bot] of this.bots) {
      if (bot.logger) {
        bot.logger.pauseLogs = true;
      }
    }
  }

  /**
   * Resume os logs dos bots
   */
  resumeLogs() {
    for (const [botName, bot] of this.bots) {
      if (bot.logger) {
        bot.logger.pauseLogs = false;
      }
    }
  }
}

export default MultiBotManager; 