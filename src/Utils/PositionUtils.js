import Logger from './Logger.js';
import CachedOrdersService from './CachedOrdersService.js';

class PositionUtils {
  /**
   * Busca ordens filtradas por posicionamento vs pre√ßo atual
   * @param {string} symbol - S√≠mbolo do mercado
   * @param {object} position - Dados da posi√ß√£o
   * @param {object} config - Configura√ß√£o com credenciais API
   * @param {function} filterLogic - Fun√ß√£o que recebe (triggerValue, currentPrice, isLong) e retorna boolean
   * @param {string} orderTypeName - Nome do tipo para logs
   * @returns {Promise<Array>} Array de ordens filtradas
   */
  static async getFilteredOrders(symbol, position, config, filterLogic, orderTypeName) {
    try {
      if (!config?.apiKey || !config?.apiSecret) {
        throw new Error('API_KEY e API_SECRET s√£o obrigat√≥rios');
      }

      const allOrders = await CachedOrdersService.getOpenOrders(
        symbol,
        'PERP',
        config.apiKey,
        config.apiSecret
      );

      // üîí VALIDA√á√ÉO CR√çTICA: Garante que allOrders √© um array iter√°vel antes do loop
      if (!allOrders || !Array.isArray(allOrders)) {
        Logger.warn(
          `‚ö†Ô∏è [ORDER_FILTER] allOrders n√£o √© um array v√°lido para ${symbol}: ${typeof allOrders}`
        );
        return [];
      }

      if (allOrders.length === 0) {
        return [];
      }

      const filteredOrders = [];

      // üîí CORRE√á√ÉO: Busca pre√ßo atual se n√£o estiver dispon√≠vel na posi√ß√£o
      let currentPrice = parseFloat(position.markPrice);
      if (!currentPrice || isNaN(currentPrice)) {
        try {
          const Markets = (await import('../Backpack/Public/Markets.js')).default;
          const markets = new Markets();
          const priceData = await markets.getAllMarkPrices(symbol);

          if (Array.isArray(priceData) && priceData.length > 0) {
            currentPrice = parseFloat(priceData[0].markPrice);
          } else if (priceData && priceData.markPrice) {
            currentPrice = parseFloat(priceData.markPrice);
          }

          if (!currentPrice || isNaN(currentPrice)) {
            Logger.error(`‚ùå [ORDER_FILTER] N√£o foi poss√≠vel obter pre√ßo atual para ${symbol}`);
            return [];
          }

          Logger.debug(`üîç [ORDER_FILTER] ${symbol}: Pre√ßo atual obtido via API: $${currentPrice}`);
        } catch (error) {
          Logger.error(`‚ùå [ORDER_FILTER] Erro ao buscar pre√ßo para ${symbol}: ${error.message}`);
          return [];
        }
      }

      const isLong = parseFloat(position.netQuantity) > 0;

      for (const order of allOrders) {
        const triggerRaw =
          order.triggerPrice ??
          order.price ??
          order.stopLossTriggerPrice ??
          order.stopLossLimitPrice;
        const triggerValue = triggerRaw != null ? Number(triggerRaw) : null;

        if (triggerValue !== null && Number.isFinite(triggerValue)) {
          if (filterLogic(triggerValue, currentPrice, isLong)) {
            filteredOrders.push(order);
          }
        }
      }

      Logger.debug(
        `üîç [ORDER_FILTER] ${symbol}: Encontradas ${filteredOrders.length} ordens de ${orderTypeName} de ${allOrders.length} ordens totais`
      );

      return filteredOrders;
    } catch (error) {
      Logger.error(
        `‚ùå [ORDER_FILTER] Erro ao buscar ordens ${orderTypeName} para ${symbol}:`,
        error.message
      );
      return [];
    }
  }

  /**
   * Busca ordens de Stop Loss para um s√≠mbolo
   */
  static async getStopLossOrders(symbol, position, config) {
    return await this.getFilteredOrders(
      symbol,
      position,
      config,
      (triggerValue, currentPrice, isLong) =>
        isLong ? triggerValue < currentPrice : triggerValue > currentPrice,
      'Stop Loss'
    );
  }

  /**
   * Busca ordens de Take Profit para um s√≠mbolo
   */
  static async getTakeProfitOrders(symbol, position, config) {
    return await this.getFilteredOrders(
      symbol,
      position,
      config,
      (triggerValue, currentPrice, isLong) =>
        isLong ? triggerValue > currentPrice : triggerValue < currentPrice,
      'Take Profit'
    );
  }

  /**
   * Verifica se existe pelo menos uma ordem de Stop Loss v√°lida
   * @param {string} symbol - S√≠mbolo do mercado
   * @param {object} position - Dados da posi√ß√£o
   * @param {object} config - Configura√ß√£o com credenciais API
   * @returns {Promise<boolean>} True se existe Stop Loss
   */
  static async hasStopLoss(symbol, position, config) {
    try {
      const stopLossOrders = await this.getStopLossOrders(symbol, position, config);
      return stopLossOrders.length > 0;
    } catch (error) {
      Logger.error(
        `‚ùå [STOP_LOSS_UTILS] Erro ao verificar exist√™ncia de Stop Loss para ${symbol}:`,
        error.message
      );
      return false;
    }
  }

  /**
   * Verifica se existe pelo menos uma ordem de Take Profit v√°lida
   * @param {string} symbol - S√≠mbolo do mercado
   * @param {object} position - Dados da posi√ß√£o
   * @param {object} config - Configura√ß√£o com credenciais API
   * @returns {Promise<boolean>} True se existe Take Profit
   */
  static async hasTakeProfit(symbol, position, config) {
    try {
      const takeProfitOrders = await this.getTakeProfitOrders(symbol, position, config);
      return takeProfitOrders.length > 0;
    } catch (error) {
      Logger.error(
        `‚ùå [STOP_LOSS_UTILS] Erro ao verificar exist√™ncia de Take Profit para ${symbol}:`,
        error.message
      );
      return false;
    }
  }
}

export default PositionUtils;
